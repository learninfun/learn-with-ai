

1. Functions are first-class citizens, which means they can be assigned to variables, passed as arguments to other functions, and returned as values from functions.

2. Pure functions are the cornerstone of functional programming. They have no side effects and always return the same output for a given input, which makes them easier to test, reason about, and compose with other functions.

3. Higher-order functions are functions that operate on other functions or their result values. They can be used to abstract common patterns, such as map, filter, and reduce, or to create new functions based on existing ones.

4. Recursion is a common technique in functional programming, which allows a function to call itself with smaller inputs until it reaches a base case. It can be used to solve many problems, such as traversing trees or computing factorials.

5. Immutable data structures are preferred in functional programming, which means that once created, they cannot be modified. This makes them safer to use in concurrent or distributed environments, where multiple threads or processes can access the same data.

6. Composition is a powerful technique in functional programming, which allows developers to build complex systems from simple building blocks. By combining functions that perform specific tasks, developers can create new functions that solve more complex problems.

7. Higher-order types, such as functors, monads, and applicatives, are advanced concepts in functional programming that provide abstractions for common patterns, such as working with collections, handling errors, or dealing with side effects.

8. Functional programming emphasizes declarative programming over imperative programming. This means that developers focus on specifying what should be done, not how it should be done. This allows for more concise, readable, and maintainable code.