

1. 求一個n x n矩陣的轉置矩陣
Best-Case Time Complexity：O(n^2)
答案：將矩陣遍歷一遍，將第i列與第j行的元素交換位置，其中i < j。

2. 給定一個有序數組和一個目標值，查找目標值的索引。如果目標值不存在，返回-1。
Best-Case Time Complexity：O(1)
答案：當目標值在數組的中央位置時，查找的時間最短，此時的時間複雜度是O(1)。

3. 給定一個包含n個數的數組，找到所有的3個數的組合，使得它們的總和為0。
Best-Case Time Complexity：O(n^2)
答案：采用雙指針法，將數組排序，遍歷每個數字，設一個左指針和一個右指針，分別指向該數字的下一個和數組的最後一個元素，判斷三個數之和是否為0，如果小於0，左指針就往右移，如果大於0，右指針就往左移。

4. 給定一個字符串，找到最長的不包含重複字符的子串。
Best-Case Time Complexity：O(n)
答案：采用滑動窗口法，記錄每個字符出現的位置，當遇到重複字符時，將窗口左端點移到該字符上一次出現的位置的下一個位置。

5. 給定一個具有n個節點的二叉搜索樹，找到其中第k小的元素。
Best-Case Time Complexity：O(h + k)，h為樹的高度
答案：使用中序遍歷，在遍歷的過程中，計數器不斷累加，當計數器的值等於k時，返回當前節點的值。因為二叉搜索樹的中序遍歷結果是一個有序的數組，所以在最好情況下，只需要遍歷到第k個節點就可以結束遍歷。