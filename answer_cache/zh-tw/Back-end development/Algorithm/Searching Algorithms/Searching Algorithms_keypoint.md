

1. Linear Search: 一個簡單的搜尋演算法，透過從頭開始，逐一檢查陣列中的元素是否符合搜尋條件；時間複雜度為O(n)。 

2. Binary Search: 將一個已排序的陣列分為兩部分，並透過比較搜尋值大小，判斷目標值可能在哪一個區域，最後從該區域繼續執行二分搜尋；時間複雜度為O(log n)。

3. Jump Search: 在已排序的陣列中，以跳躍的方式搜尋目標值，較為快速，時間複雜度為O(√n)。

4. Interpolation Search：在已排序的數列中，透過數值大小的估計，更快地找到目標值所在的位置；時間複雜度為O(log log n)。

5. Exponential Search: 先進行指數級的搜尋，當有足夠接近目標值的範圍時，再轉為二分搜尋，通常適用於整數搜尋；時間複雜度為O(log n)。

6. Hashing: 透過hash function將目標值轉換為一個索引值，以快速尋找目標值的位置；時間複雜度為O(1)。 

7. Depth-First Search(DFS): 借助stack實現，遍歷整個圖或樹的節點，並依此搜尋目標值所在的節點；時間複雜度為O(V+E)。

8. Breadth-First Search(BFS): 借助queue實現，從起點開始一層一層向外擴展，並依此搜尋目標值所在的節點；時間複雜度為O(V+E)。

9. A* Search: 求解最短路徑問題，以估價函數為基礎評估每個節點的價值，選擇最優的路徑；時間複雜度為O(b^d)。

10. Dijkstra's Algorithm: 求解最短路徑問題，以當前距離為基礎計算每個節點到起點的距離，選擇最短的路徑；時間複雜度為O(E log V)。