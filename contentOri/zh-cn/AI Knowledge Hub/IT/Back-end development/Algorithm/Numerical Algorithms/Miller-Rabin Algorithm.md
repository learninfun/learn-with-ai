+++
title = "米勒-拉宾质数判定算法"
weight = "7"
+++
## 习题预习
{{< ask_chatgpt >}}
给我5题Miller-Rabin Algorithm的中文问题
{{< /ask_chatgpt >}}



1. 什么是Miller-Rabin Algorithm (MRA)？它与其他素性测试算法的区别是什么？
2. MRA如何判断一个数是否为质数？它的运行时间是多少？
3. MRA在什么情况下可能会给出错误的结果？该如何解决这个问题？
4. MRA是否可应用于大数据范围内的质数判断？如果可以，需要注意哪些问题？
5. MRA的应用场景有哪些？该算法的优点和缺点是什么？   

## 说明知识
{{< ask_chatgpt >}}
以中文说明Miller-Rabin Algorithm并举例
{{< /ask_chatgpt >}}



Miller-Rabin Algorithm是一种概率性质质数测试法，用于检测一个数字是否为质数。它基于Fermat's Little Theorem和二次剩余的性质，在确定一个数字是否为质数时，比起其他传统的质数测试算法，如暴力测试法或埃拉托色尼质数筛法，更加高效。

Miller-Rabin Algorithm的演算法流程如下：

1. 将欲判断的数字n-1表示成 2^s * d 的形式，其中d为奇数。
2. 随机选择一个小于n的整数a作为底数。
3. 计算a^d mod n，若 a^d ≡ 1 (mod n) 或 a^(2^r * d) ≡ -1 (mod n) 就判定这是质数或可能是错误的。其中r∈[0,s-1]
4. 如果验证不是质数，则继续对a重新选择底数，重复步骤2-3，若经过k次验证皆为质数或可能是错误的，就判定n为质数；若经过k次验证存在不合法的结果，就判定n为合数。

以下是一个Miller-Rabin Algorithm的例子：

我们想要确认60是否为质数。

1. 60-1可以表示成 2^2 * 15的形式。
2. 选择一个随机底数a = 2。
3. 计算2^15 mod 60，得到32。
4. 因为2^30 ≡ 1 (mod 60)，所以我们可以进行以下的判断式：

  2^2 * 15 = 60-1
  2^15 ≡ 32 (mod 60)
  2^30 ≡ 1 (mod 60)
  
  因此，2^60 ≡ (2^30)^2 ≡ 1 (mod 60)，所以60可能是错误的质数，我们需要继续进行验证。
  
5. 我们再次选择底数a = 7。
6. 计算7^15 mod 60，得到49。
7. 我们也可以进行以下的判断式：

  7^2 ≡ 49 ≡ -11 (mod 60)
  7^4 ≡ (-11)^2 ≡ 121 ≡ 1 (mod 60)
  
  因此，7^15 ≡ (7^4) * (7^4) * 7^2 ≡ 1 (mod 60)，所以60可能是错误的质数，我们需要再次继续验证。
  
8. 我们再次选择底数a = 11。
9. 计算11^15 mod 60，得到49。
10. 进行以下判断：

  11^2 ≡ 1 (mod 60)
  11^4 ≡ 1 (mod 60)
  
  因此，11^15 ≡ (11^4) * (11^4) * 11^2 ≡ 1 (mod 60)，所以我们可以确定60是错误的合数。

因此，我们可以确定60是错误的合数，不是质数。 如此反覆执行，直到分别执行了k次测试都没有成功，我们才能够大致得到一个数字是否是质数。   

## 条列重点
{{< ask_chatgpt >}}
以中文条列Miller-Rabin Algorithm的重点
{{< /ask_chatgpt >}}



1. Miller-Rabin算法是一种用于快速判定一个数是否为素数的概率算法。
2. 这种算法基于费马小定理以及阿基米德反演等数论知识，通过随机选取若干个基数来检测是否为素数。
3. Miller-Rabin算法针对伪素数的概率给出了一个极小值，因此在实际应用中已经被广泛使用。
4. 通过设置适当的检测次数，可以将检测出错的概率降到极低，从而确定一个数是否为素数。
5. 由于复杂度相对较低，Miller-Rabin算法被广泛地应用在计算机理论、加密系统等领域。   

## 知识测验
{{< ask_chatgpt >}}
以中文给我5题Miller-Rabin Algorithm的中等难度问题，并在后面列出答案
{{< /ask_chatgpt >}}



1. 对于一个给定的奇数 n，假设 a 是其中一个小于 n 的整数。如何使用 Miller-Rabin Algorithm 验证 a 是否是 n 的一个质数证人？

答案：以 k 次随机选取的 a 为例，将 n - 1 表示为 d * 2^s 的形式，其中 d 是奇数，s >= 1。接下来用快速幂算法计算 a^d mod n，如果得到的结果等于 1 或 n - 1，停止计算，并认为 a 是 n 的可能质数证人。如果结果不等于 1 或 n - 1，计算 a^(2^r * d) mod n，直到 r = s 或得到的结果等于 n - 1。如果最后得到的结果等于 n - 1，则仍认为 a 是 n 的可能质数证人。否则认为 a 不是 n 的质数证人。

2. 使用 Miller-Rabin Algorithm 求一个大质数（大于 10^10）的可能质数证人。 

答案：多次随机选取 a 进行测试，如果每次测试都得到 a 为 n 的可能质数证人，则有很高的概率认为 n 是质数。要注意选取的 a 需要小于 n，可使用随机数生成器达到这个目的。

3. 对于一个给定的奇数 n，使用 Miller-Rabin Algorithm 找到一个质数 p，使得 n - p 是一个平方数。

答案：如果 n 是质数，则 p = 2 是说是可以的。如果 n 不是质数，则可以随机选取 a 进行测试。如果得到 a 是 n 的一个可能质数证人，则有很高概率认为 n 是合数。此时可以计算 b = sqrt(n - 1)，如果 b 是一个整数，则 p = n - b^2 是一个质数。

4. 对于一个给定的质数 p，使用 Miller-Rabin Algorithm 判断是否存在一个 a，使得 a 是 p 的原根。

答案：对于 p 的每个质因子 q，如果 q = 2 或 p / q = 2，则 p 中不存在原根。否则，可以使用随机选取的 a 进行测试。如果得到 a 是 p 的可能质数证人，则有很高概率认为 a 是 p 的原根。此时计算 phi(p) 和其所有质因子的乘积，如果  a^((p-1) / q) mod p 不为 1，对于所有的质因子 q，则认为 a 是 p 的原根。

5. 对于一个给定的奇数 n，使用 Miller-Rabin Algorithm 判断是否存在一个奇数 g，使得 g 是 n 的原根。

答案：可以随机选取一个质数 p，使得 p 是 n 的一个质因子。然后选取一个小于 p 的整数 a，计算 g = a^((p-1) * (n-1) / phi(n)) mod n。如果 g 不等于 1，则有很高概率认为 g 是 n 的原根。否则，换一个 a 重新计算。如果 p 不能选出，则需要用更高级的算法解决问题。   

