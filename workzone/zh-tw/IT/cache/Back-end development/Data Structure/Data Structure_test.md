

1. 面試中經常出現的問題是，如何實現一個栈，其中除了常規操作（push，pop）外還包含另一個操作min，可以在常數時間複雜度下返回栈中的最小元素。該算法如何實現？

答案：

可以使用兩個堆棧：一個用於存儲值，另一個用於存儲最小值。在每次推入新元素時，都需要更新最小值堆棧。最小值堆棧中的每個元素都是與主堆棧相應位置的最小值，這就使得查找最小值變得非常容易且簡單。

2. 給出一個包含n個整數的數組，其中每個元素都表示你可以向前或向後跳躍的最大步數，請找到數組最少可以跳躍幾次到達最後一個元素。

例如，給定數組[2,3,1,1,4]，最少跳躍2次可以到達最後一個位置。

答案：

這個問題可以用貪心算法解決。我們從左到右滑動，根據當前位置和當前的可用步數，選擇最佳跳躍位置。我們不斷地重複這個過程，直到達到最後一個位置。這種算法的時間複雜度為O(nlogn)。

3. 實現一個LRU緩存，它可以在常數時間內執行get和put操作。當緩存容量達到上限時，最近最少使用的元素應該被移除。

答案：

實現LRU緩存所需要的基本數據結構是哈希表和雙向鏈表。在緩存中，哈希表可以根據鍵查找值，而雙向鏈表可以根據每個元素的使用情況來將它們排序。為了實現LRU操作，當某個元素被使用時，必須將它移動到鏈表的最前面。在插入新元素時，如果緩存大小超過限制，則將最久未使用的元素移除。這可以通過維護一個指向鏈表尾部的指針來實現。

4. 給定一個n x n的矩陣，其元素均為0或1。請計算其中最大的正方形的面積，其元素均為1。

例如：

1101
1101
1111
0111

在這個矩陣中，最大的正方形面積為9。

答案：

使用動態規劃法解決這個問題。維護一個n x n的數組，其中cell[i][j]存儲最大正方形邊長，以cell[i-1][j]，cell[i][j-1]和cell[i-1][j-1]作為優化目標依次檢查每個元素。如果元素(cell[i][j])為1，則檢查相鄰的元素，並計算能夠擴展到的最大正方形的邊長。如果該值大於cell[i][j]，則更新cell[i][j]的值。

5. 給定一個字符串s，請找出最長的子串t，該子串中每個字符都出現至少k次，k是一個給定的正整數。例如，如果s = "ababbc"，k = 2，那麼"ababb"是一個合法的子串。

答案：

這是一個基於分治和哈希的算法。該算法可以使用分治法，將字符串分成多個子串，該問題可以進一步細分為子問題。可以使用另一個函數，計算在一個字串中每個字符的出現次數。最終，可以通過在查找過程中檢查每個子串來找到最長的合法子串。