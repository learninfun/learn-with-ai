

1. The decorator pattern allows fluidly adding functionality to a class at runtime.

2. It works by creating a decorator class that wraps the original class.

3. The decorator class implements the same interface as the original class and delegates to the original class.

4. The decorator class can add additional behavior before or after the original class's methods.

5. Multiple decorators can be layered on top of each other to add more functionality.

6. Decorators can be used to add functionality without modifying the original class.

7. The Decorator pattern follows the Open/Closed principle - the original class remains open to extension but closed to modification.

8. It can be used when you want to add functionality to an object at runtime, instead of creating a subclass.

9. It can also be used to add optional features to core functionality.

10. The Decorator pattern is commonly used in GUI frameworks, where decorators can be used to add borders, scrollbars, etc. to a component.