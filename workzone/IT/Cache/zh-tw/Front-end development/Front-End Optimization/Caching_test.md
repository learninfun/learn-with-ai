

1. 給定一個有 $n$ 個元素的整數陣列和一個整數 $k$，請設計一個支持查詢區間和的數據結構，要求時間複雜度為 $O(n\sqrt{n} + q\sqrt{n}\log n)$，其中 $q$ 為查詢數量。

2. 設計一個線性時間複雜度的算法，查詢一個區間中出現次數最多的元素及其出現次數。

3. 給定一個長度為 $n$ 的字符串 $S$，設計一個數據結構支持以下操作：

   - 將某個位置的字符修改為另一個字符。
   - 查詢某個子串在原串中出現的次數。

   要求修改和查詢操作的時間複雜度均為 $O(\sqrt{n})$。

4. 設計一個數據結構，支持以下操作：

   - 將一個元素加入集合中。
   - 從集合中刪除一個元素。
   - 查詢某個區間內元素的個數。

   其中，添加和刪除操作的時間複雜度均為 $O(\sqrt{n})$，查詢操作的時間複雜度為 $O(q\sqrt{n}\log n)$，其中 $q$ 為查詢次數。

5. 設計一個數據結構，支持以下操作：

   - 在序列中插入一個元素。
   - 刪除序列中的某個元素。
   - 查詢某個位置後面第 $k$ 小的元素。

   其中，插入和刪除操作的時間複雜度均為 $O(\sqrt{n})$，查詢操作的時間複雜度為 $O(q\sqrt{n}\log n)$，其中 $q$ 為查詢次數。

答案：

1. 利用分塊和前綴和，在每個塊上建立一棵平衡樹（如紅黑樹），支持區間查詢的時間複雜度為 $O(\sqrt{n}\log n)$，將每個塊區間和緩存起來，單次查詢的時間複雜度為 $O(\sqrt{n})$。
2. 將序列分為若干塊，對每個塊統計出現次數最多的元素和出現次數，總時間複雜度為 $O(n)$。對於一個查詢區間 $[l,r]$，若 $l$ 和 $r$ 落在同一個塊中，直接遍歷區間統計出現次數即可；否則分別遍歷區間左右端點所在的塊，並統計其中出現次數最多的元素及其出現次數，然後在這些塊中遍歷 $l$ 和 $r$ 所在的塊中非區間的元素，統計其出現次數，最終比較三者出現次數，返回出現次數最多的那個元素及其出現次數。
3. 將字符串劃分成 $\sqrt{n}$ 個塊，對每個塊建立一棵 Trie（字典樹），在 Trie 上標記每個節點對應的字串在原串中出現的次數，緩存每個塊中所有子串的出現次數，查詢時統計相應塊中子串的出現次數，然後在相應的 Trie 上遍歷所查詢的子串，統計其出現次數，最終返回所有統計值的和。修改操作可以在 Trie 上進行，時間複雜度為 $O(|T|)$，其中 $T$ 為 Trie 的節點數，對於一個子串修改，只需找到相應的 Trie 和其對應的節點，然後修改該節點的標記，時間複雜度為 $O(\sqrt{n}+\log m)$，其中 $m$ 為字元集大小。
4. 將集合分割成 $\sqrt{n}$ 個塊，對於每個塊使用哈希表和平衡樹（如紅黑樹）進行支持添加和刪除操作，時間複雜度均為 $O(\sqrt{n})$。對於一個查詢區間 $[l,r]$，若 $l$ 和 $r$ 落在同一個塊中，直接遍歷區間統計元素個數；否則分別遍歷區間左右端點所在的塊，然後在這些塊中遍歷 $l$ 和 $r$ 所在的塊中非區間的元素，統計其出現次數，最終返回統計值的和。總時間複雜度為 $O(n\sqrt{n}+q\sqrt{n}\log n)$。
5. 將序列分為 $\sqrt{n}$ 個塊，對於每個塊使用一棵支持重複元素的排序算法（如 std::multiset）進行排序，時間複雜度為 $O(\sqrt{n}\log\sqrt{n})$。將每個塊中的第 $k$ 小的元素緩存起來，總時間複雜度為 $O(n\sqrt{n})$。對於一個插入或刪除操作，只需找到相應的塊，更新該塊中的排序算法，更新緩存中的第 $k$ 小元素，時間複雜度為 $O(\sqrt{n}\log\sqrt{n})$。對於一個查詢操作，若要查詢的位置位於某個塊中，直接在該塊中進行查詢；否則先在位置左邊的塊中查詢其後第 $k$ 小的元素，然後在位置右邊的塊中查詢其前 $k-1$ 小的元素，最終找出所有結果的前 $k$ 小的元素，總時間複雜度為 $O(q\sqrt{n}\log\sqrt{n})$。