

Knuth-Morris-Pratt (KMP)算法是解决字符串匹配问题的高效算法之一，用于在主串中查找模式串的匹配位置。

算法思想：

KMP算法的基本思想是不回溯主串指针i，而是通过在模式串中预先构建出一个next[]数组，来记录模式串的自匹配情况。当发生不匹配时，i指针不回溯，只需移动一定距离，这样既能提高匹配效率，又能减少匹配次数。

next[]数组的构建：

next[i]表示在i位置之前的子串中，前缀和后缀最长的匹配长度。例如：P = “ABAB”，在i=3(第四个字符)的时候，前缀是"ABA"，后缀是“BA”，并且两者长度相等，所以next[3]=2。

构建next[]数组的过程可以使用动态规划的思想，通过递推的方式求解。该过程可以大致分为以下几步：

1）next[0] = -1；next[1] = 0；

2）从i=2开始逐一计算，设i-1位置的next值为nextval，则有：

(1)如果P[i-1] == P[nextval]，则next[i] = nextval+1；

(2)如果P[i-1] != P[nextval]且nextval != -1，则需要回退，计算next[P[nextval]]；

(3)如果P[i-1] != P[nextval]且nextval = -1，则next[i]=0；

模式串匹配：

当模式串的next[]数组构建完成后，就可以在主串S中查找模式串P的匹配位置，这个过程相对简单：

1）初始化主串指针i=0，模式串指针j=0；

2）如果S[i] == P[j]，则i++,j++；

3）如果S[i] != P[j]，则需要移动模式串指针j，根据next[j]值来决定移动距离；

4）如果j等于模式串P的长度，说明匹配成功，返回主串当前位置i与模式串长度的差值即可；否则继续匹配。

示例：

主串S：BBC ABCDAB ABCDABCDABDE

模式串P：ABCDABD

next[]数组：[-1,0,0,0,0,1,2,0]

假设在主串S的第9个位置开始查找，匹配过程如下：

S  B  C  D  A  B  C  D  A  B  C  D  A  B  D  E
   P  A  B  C  D  A  B  D

1) S[9] != P[0]，移动模式串指针，j=next[0]= -1+1=0；

S  B  C  D  A  B  C  D  A  B  C  D  A  B  D  E
         P  A  B  C  D  A  B  D

2) S[9] == P[0], S[10] == P[1], S[11] == P[2]，经过三轮比较，匹配成功，返回i与模式串长度的差值，即9。

时间复杂度：

KMP算法的时间复杂度为O(n+m)，其中n和m分别是主串和模式串的长度。相比于朴素的字符串匹配算法，KMP算法具有更高的效率和更低的时间复杂度，适用于大规模字符串匹配问题的解决。