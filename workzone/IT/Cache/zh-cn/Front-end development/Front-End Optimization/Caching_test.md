

1. 给定一个有 $n$ 个元素的整数阵列和一个整数 $k$，请设计一个支持查询区间和的数据结构，要求时间复杂度为 $O(n\sqrt{n} + q\sqrt{n}\log n)$，其中 $q$ 为查询数量。

2. 设计一个线性时间复杂度的算法，查询一个区间中出现次数最多的元素及其出现次数。

3. 给定一个长度为 $n$ 的字符串 $S$，设计一个数据结构支持以下操作：

   - 将某个位置的字符修改为另一个字符。
   - 查询某个子串在原串中出现的次数。

   要求修改和查询操作的时间复杂度均为 $O(\sqrt{n})$。

4. 设计一个数据结构，支持以下操作：

   - 将一个元素加入集合中。
   - 从集合中删除一个元素。
   - 查询某个区间内元素的个数。

   其中，添加和删除操作的时间复杂度均为 $O(\sqrt{n})$，查询操作的时间复杂度为 $O(q\sqrt{n}\log n)$，其中 $q$ 为查询次数。

5. 设计一个数据结构，支持以下操作：

   - 在序列中插入一个元素。
   - 删除序列中的某个元素。
   - 查询某个位置后面第 $k$ 小的元素。

   其中，插入和删除操作的时间复杂度均为 $O(\sqrt{n})$，查询操作的时间复杂度为 $O(q\sqrt{n}\log n)$，其中 $q$ 为查询次数。

答案：

1. 利用分块和前缀和，在每个块上建立一棵平衡树（如红黑树），支持区间查询的时间复杂度为 $O(\sqrt{n}\log n)$，将每个块区间和缓存起来，单次查询的时间复杂度为 $O(\sqrt{n})$。
2. 将序列分为若干块，对每个块统计出现次数最多的元素和出现次数，总时间复杂度为 $O(n)$。对于一个查询区间 $[l,r]$，若 $l$ 和 $r$ 落在同一个块中，直接遍历区间统计出现次数即可；否则分别遍历区间左右端点所在的块，并统计其中出现次数最多的元素及其出现次数，然后在这些块中遍历 $l$ 和 $r$ 所在的块中非区间的元素，统计其出现次数，最终比较三者出现次数，返回出现次数最多的那个元素及其出现次数。
3. 将字符串划分成 $\sqrt{n}$ 个块，对每个块建立一棵 Trie（字典树），在 Trie 上标记每个节点对应的字串在原串中出现的次数，缓存每个块中所有子串的出现次数，查询时统计相应块中子串的出现次数，然后在相应的 Trie 上遍历所查询的子串，统计其出现次数，最终返回所有统计值的和。修改操作可以在 Trie 上进行，时间复杂度为 $O(|T|)$，其中 $T$ 为 Trie 的节点数，对于一个子串修改，只需找到相应的 Trie 和其对应的节点，然后修改该节点的标记，时间复杂度为 $O(\sqrt{n}+\log m)$，其中 $m$ 为字元集大小。
4. 将集合分割成 $\sqrt{n}$ 个块，对于每个块使用哈希表和平衡树（如红黑树）进行支持添加和删除操作，时间复杂度均为 $O(\sqrt{n})$。对于一个查询区间 $[l,r]$，若 $l$ 和 $r$ 落在同一个块中，直接遍历区间统计元素个数；否则分别遍历区间左右端点所在的块，然后在这些块中遍历 $l$ 和 $r$ 所在的块中非区间的元素，统计其出现次数，最终返回统计值的和。总时间复杂度为 $O(n\sqrt{n}+q\sqrt{n}\log n)$。
5. 将序列分为 $\sqrt{n}$ 个块，对于每个块使用一棵支持重复元素的排序算法（如 std::multiset）进行排序，时间复杂度为 $O(\sqrt{n}\log\sqrt{n})$。将每个块中的第 $k$ 小的元素缓存起来，总时间复杂度为 $O(n\sqrt{n})$。对于一个插入或删除操作，只需找到相应的块，更新该块中的排序算法，更新缓存中的第 $k$ 小元素，时间复杂度为 $O(\sqrt{n}\log\sqrt{n})$。对于一个查询操作，若要查询的位置位于某个块中，直接在该块中进行查询；否则先在位置左边的块中查询其后第 $k$ 小的元素，然后在位置右边的块中查询其前 $k-1$ 小的元素，最终找出所有结果的前 $k$ 小的元素，总时间复杂度为 $O(q\sqrt{n}\log\sqrt{n})$。