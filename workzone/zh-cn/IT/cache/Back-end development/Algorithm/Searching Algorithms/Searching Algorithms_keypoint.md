

1. Linear Search: 一个简单的搜寻演算法，透过从头开始，逐一检查阵列中的元素是否符合搜寻条件；时间复杂度为O(n)。 

2. Binary Search: 将一个已排序的阵列分为两部分，并透过比较搜寻值大小，判断目标值可能在哪一个区域，最后从该区域继续执行二分搜寻；时间复杂度为O(log n)。

3. Jump Search: 在已排序的阵列中，以跳跃的方式搜寻目标值，较为快速，时间复杂度为O(√n)。

4. Interpolation Search：在已排序的数列中，透过数值大小的估计，更快地找到目标值所在的位置；时间复杂度为O(log log n)。

5. Exponential Search: 先进行指数级的搜寻，当有足够接近目标值的范围时，再转为二分搜寻，通常适用于整数搜寻；时间复杂度为O(log n)。

6. Hashing: 透过hash function将目标值转换为一个索引值，以快速寻找目标值的位置；时间复杂度为O(1)。 

7. Depth-First Search(DFS): 借助stack实现，遍历整个图或树的节点，并依此搜寻目标值所在的节点；时间复杂度为O(V+E)。

8. Breadth-First Search(BFS): 借助queue实现，从起点开始一层一层向外扩展，并依此搜寻目标值所在的节点；时间复杂度为O(V+E)。

9. A* Search: 求解最短路径问题，以估价函数为基础评估每个节点的价值，选择最优的路径；时间复杂度为O(b^d)。

10. Dijkstra's Algorithm: 求解最短路径问题，以当前距离为基础计算每个节点到起点的距离，选择最短的路径；时间复杂度为O(E log V)。