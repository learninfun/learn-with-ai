

1. 求一个n x n矩阵的转置矩阵
Best-Case Time Complexity：O(n^2)
答案：将矩阵遍历一遍，将第i列与第j行的元素交换位置，其中i < j。

2. 给定一个有序数组和一个目标值，查找目标值的索引。如果目标值不存在，返回-1。
Best-Case Time Complexity：O(1)
答案：当目标值在数组的中央位置时，查找的时间最短，此时的时间复杂度是O(1)。

3. 给定一个包含n个数的数组，找到所有的3个数的组合，使得它们的总和为0。
Best-Case Time Complexity：O(n^2)
答案：采用双指针法，将数组排序，遍历每个数字，设一个左指针和一个右指针，分别指向该数字的下一个和数组的最后一个元素，判断三个数之和是否为0，如果小于0，左指针就往右移，如果大于0，右指针就往左移。

4. 给定一个字符串，找到最长的不包含重复字符的子串。
Best-Case Time Complexity：O(n)
答案：采用滑动窗口法，记录每个字符出现的位置，当遇到重复字符时，将窗口左端点移到该字符上一次出现的位置的下一个位置。

5. 给定一个具有n个节点的二叉搜索树，找到其中第k小的元素。
Best-Case Time Complexity：O(h + k)，h为树的高度
答案：使用中序遍历，在遍历的过程中，计数器不断累加，当计数器的值等于k时，返回当前节点的值。因为二叉搜索树的中序遍历结果是一个有序的数组，所以在最好情况下，只需要遍历到第k个节点就可以结束遍历。